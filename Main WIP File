let level = 0;
let maxLevels = 10;

let particles = [];
let orbs = [];

let transitionAlpha = 0;
let transitionState = 'NONE';
let transitionStartX = 0;
let transitionStartY = 0;
let transitionRadius = 0;

let hasSplit = false;

let bgCol = 0;
let mainColor = 255;

function spawnParticles(x, y, count, colorValue) {
  for(let i=0; i<count; i++) {
    particles.push(new Particle(x, y, colorValue));
  }
}

function updateParticles() {
  for(let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].draw();
    if (particles[i].isDead()) particles.splice(i, 1);
  }
}

class Particle {
  constructor(x, y, colorValue) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D().mult(random(10, 25));
    this.alpha = 255;
    this.colorValue = color(colorValue);
    this.size = random(6, 12);
    this.drag = 0.96;
  }

  update() {
    this.pos.add(this.vel);
    this.vel.mult(this.drag);
    this.alpha -= 12;
    this.size *= 0.95;
  }

  draw() {
    noStroke();
    this.colorValue.setAlpha(this.alpha);
    fill(this.colorValue);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  isDead() {
    return this.alpha <= 0;
  }
}

class Orb {
  constructor(x, y, behavior = 'STATIC') {
    this.pos = createVector(x, y);
    this.size = 50;
    this.color = mainColor;
    this.behavior = behavior;
    this.isHovered = false;
  }

  update() {
    if (this.behavior === 'CHASE') {
      let d = dist(mouseX, mouseY, this.pos.x, this.pos.y);
      let speed = 7;

      if (d < 200) {
        let vec = createVector(this.pos.x - mouseX, this.pos.y - mouseY);
        vec.normalize();
        vec.rotate(random(-0.5, 0.5));
        vec.mult(speed);
        this.pos.add(vec);

        if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height) {
             this.pos.x = width / 2;
             this.pos.y = height / 2;
        }
      }
    }

    this.isHovered = (dist(mouseX, mouseY, this.pos.x, this.pos.y) < this.size);
  }

  display() {
    let p = sin(frameCount * 0.1) * (this.size * 0.2);
    let glowAlpha = map(sin(frameCount * 0.1), -1, 1, 100, 200);
    let c = color(this.color);

    fill(red(c), green(c), blue(c), 50);
    ellipse(this.pos.x, this.pos.y, this.size + p*2);

    fill(red(c), green(c), blue(c), glowAlpha);
    ellipse(this.pos.x, this.pos.y, this.size + p);

    fill(c);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

function runLevel() {
  let anyHover = false;

  for (let orb of orbs) {
    orb.update();
    orb.display();
    if (orb.isHovered) anyHover = true;
  }

  if (anyHover) cursor('pointer');
  else cursor('default');
}

function drawTitleScreen() {
  let pulse = sin(frameCount * 0.05) * 10;
  let currentDiameter = 350 + pulse;

  noFill();
  stroke(mainColor);
  strokeWeight(8);
  ellipse(width/2, height/2, currentDiameter);

  noStroke();
  fill(mainColor);
  textAlign(CENTER, CENTER);
  textStyle(BOLD);
  textSize(100);
  text("level", width/2, height/2 - 5);

  if (dist(mouseX, mouseY, width/2, height/2) < currentDiameter / 2) {
    cursor('pointer');
  } else {
    cursor('default');
  }
}

function titleScreenClick() {
  let pulse = sin(frameCount * 0.05) * 10;
  let currentDiameter = 350 + pulse;

  if (dist(mouseX, mouseY, width / 2, height / 2) < currentDiameter / 2) {
    transitionStartX = mouseX;
    transitionStartY = mouseY;
    transitionRadius = 0;
    transitionState = 'TITLE_OUT';
    cursor('default');
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  rectMode(CENTER);
  ellipseMode(CENTER);
  resetLevel();
}

function resetLevel() {
    orbs = [];
    hasSplit = false;

    if (level % 2 === 0) {
        bgCol = 0;
        mainColor = 255;
    } else {
        bgCol = 255;
        mainColor = 0;
    }

    if (level === 1) {
        orbs.push(new Orb(width/2, height/2, 'STATIC'));
    }
    else if (level === 2) {
        orbs.push(new Orb(width/2, height/2, 'CHASE'));
    }
    else if (level >= 3) {
        orbs.push(new Orb(width/2, height/2, 'CHASE'));
    }
}

function draw() {
  background(bgCol);

  updateParticles();

  push();

  if (level === 0) {
      drawTitleScreen();
    
  } else if (level <= 10) {
      runLevel();
  } else {

      fill(mainColor);
      textAlign(CENTER);
      text("complete", width/2, height/2);
  }

  pop();

  drawUI();
  transition();
}

function drawUI() {
    if (level === 0) return;

    
    for(let i=1; i<=maxLevels; i++) {
        let alphaValue = (i <= level ? 255 : 50);
        fill(mainColor, alphaValue);

        let spacing = 23;
        let totalWidth = maxLevels * spacing;
      
        let startX = (width/2) - (totalWidth/2);
      
        ellipse(startX + (i*spacing), height - 40, 15);
      
    }
}

function startTransition() {
    transitionState = 'OUT';
    transitionAlpha = 0;
}

function transition() {
  
  
    if (transitionState === 'NONE') return;

    if (transitionState === 'OUT' || transitionState === 'IN') {
        noStroke();
        fill(0, transitionAlpha);
        rect(width/2, height/2, width, height);

        if (transitionState === 'OUT') {
            transitionAlpha += 30;
          
            if (transitionAlpha >= 255) {
              
                transitionState = 'IN';
                level++;
              
                if (level > maxLevels) level = 0;
                resetLevel();
              
              
            }
        } else if (transitionState === 'IN') {
            transitionAlpha -= 30;
          
            if (transitionAlpha <= 0) {
              
                transitionState = 'NONE';
            }
          
          
        }
    }
    else if (transitionState === 'TITLE_OUT') {
         noStroke();
         fill(255);
         ellipse(transitionStartX, transitionStartY, transitionRadius * 2);
         transitionRadius += 70;

         let maxDist = dist(0, 0, width, height);
         if (transitionRadius > maxDist) {
           
           
             level = 1;
             resetLevel();
             transitionState = 'NONE';
         }
    }
  
}

function keyPressed() {
  if (key === 'f' || key === 'F') {
      fullscreen(!fullscreen());
  }
  
  

  if (key === 'r' || key === 'R') {
    level = 0;
    transitionState = 'NONE';
    transitionAlpha = 0;
    orbs = [];
    resetLevel();
  }
}



function mousePressed() {
  if (transitionState !== 'NONE') return;

  if (level === 0) {
    let pulse = sin(frameCount * 0.05) * 10;
    let currentDiameter = 350 + pulse;
    if (dist(mouseX, mouseY, width/2, height/2) < currentDiameter / 2) {
      spawnParticles(width/2, height/2, 150, mainColor);
      titleScreenClick();
    }
    
    
    
    return;
    
    
    
    
  }

  for (let i = orbs.length - 1; i >= 0; i--) {
      let orb = orbs[i];

      if (dist(mouseX, mouseY, orb.pos.x, orb.pos.y) < orb.size) {
          spawnParticles(orb.pos.x, orb.pos.y, 150, orb.color);

          if (level >= 3) {
             orbs.splice(i, 1);

             if (!hasSplit) {
                 let spawnCount = level - 1;
                 let spreadRadius = 60;

                 for(let j=0; j < spawnCount; j++) {
                     let angle = map(j, 0, spawnCount, 0, TWO_PI);
                     let newX = orb.pos.x + cos(angle) * spreadRadius;
                     let newY = orb.pos.y + sin(angle) * spreadRadius;

                     orbs.push(new Orb(newX, newY, 'CHASE'));
                 }
                 hasSplit = true;
             }

             if (orbs.length === 0) startTransition();
             return;
          }

          else {
              startTransition();
              return;
          }
      }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);

}
