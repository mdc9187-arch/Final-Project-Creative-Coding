//"level" browser game

//prototype version consolidated into one file, main version has 7 separated files
//only one level in prototype, repeated as placeholder


// GAME OPENS TO TITLE SCREEN (LEVEL 0):
// CURRENT LEVEL SETUP:

let level = 0;

let maxLevels = 10;



// ARRAY FOR FEEDBACK PARTICLES:

let particles = [];


let target;


// TRANSITION VARIABLES
let transitionAlpha = 0;
let transitionState = 'NONE'; 

//'NONE' is default, no change
//'OUT' fades to black
//'IN' loads new level and resets to 'NONE'




// ORB SIZE SETUP :

// let orbSize = 50;

// let orbX = width / 2;
// let orbY = height * 0.6;




// COLOR BANK


const black   = 0;
const white   = 255;

const goodgreen   = '#2ed573';
const badred      = '#ff4757';


// FEEDBACK PARTICLES 

function spawnParticles(x, y, count, colorValue) {
  
  for(let i=0; i<count; i++) {
    particles.push(new Particle(x, y, colorValue));
    
  }
}

function updateParticles() {
  
  for(let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].draw();
    if (particles[i].isDead()) particles.splice(i, 1);
    
  }
}

class Particle {
  
  constructor(x, y, colorValue) {
    
    this.pos = createVector(x, y);
    
    this.vel = p5.Vector.random2D().mult(random(10, 15));
    
    this.alpha = 255;
    
    this.colorValue = color(colorValue);
    
    this.size = random(20, 25);
    
  }
  
  update() {
    
    this.pos.add(this.vel);
    this.alpha -= 5;
    this.size *= 0.95;
  }
  draw() {
    
    noStroke();
    
    this.colorValue.setAlpha(this.alpha);
    
    fill(this.colorValue);
    
    ellipse(this.pos.x, this.pos.y, this.size);
  }
  
  isDead() {
    
    return this.alpha <= 0;
    
  }
}



function drawOrb(x, y, size, colorValue) {
  let p = sin(frameCount * 0.1) * (size * 0.2);
  let alpha = map(sin(frameCount * 0.1), -1, 1, 100, 200);
  
  let c = color(colorValue);
  
  // outer
  fill(red(c), green(c), blue(c), 50);
  ellipse(x, y, size + p*2);
  
  // inner
  fill(red(c), green(c), blue(c), alpha);
  ellipse(x, y, size + p);
  
  // orb core
  fill(colorValue);
  ellipse(x, y, size);
}

// chaselevelstuff
function runChaseLevel() {
    // distance cursor to orb
    let d = dist(mouseX, mouseY, target.x, target.y);
    let speed = 7;
    
    // if mouse within 200 pixels, move away
    if (d < 200) {
        let vec = createVector(target.x - mouseX, target.y - mouseY);
        vec.normalize();
        vec.rotate(random(-0.5, 0.5)); 
        vec.mult(speed);
        target.add(vec);
        
        // lock orb in window
        target.x = constrain(target.x, 50, width-50);
        target.y = constrain(target.y, 50, height-50);
    }
    
   
    
    // draw orb

    drawOrb(target.x, target.y, 50, white);
    
    // cursor change

    if (dist(mouseX, mouseY, target.x, target.y) < 50) {
        cursor('pointer');
    } else {
        cursor('default');
    }
}

// LEVEL FUNCTIONS

function drawLevel1() { runChaseLevel(); }
function drawLevel2() { runChaseLevel(); }
function drawLevel3() { runChaseLevel(); }
function drawLevel4() { runChaseLevel(); }
function drawLevel5() { runChaseLevel(); }
function drawLevel6() { runChaseLevel(); }
function drawLevel7() { runChaseLevel(); }
function drawLevel8() { runChaseLevel(); }
function drawLevel9() { runChaseLevel(); }
function drawLevel10() { runChaseLevel(); }

function drawTitleScreen() {
 
  let pulse = sin(frameCount * 0.05) * 10;
  
  let currentDiameter = 350 + pulse;
  


  // Circle Outline

  noFill();
  stroke(white);
  strokeWeight(8);
  ellipse(width/2, height/2, currentDiameter);

  // Text "level"

  noStroke();
  fill(white);
  textAlign(CENTER, CENTER);
  textStyle(BOLD);
  textSize(100);
  text("level", width/2, height/2 - 5);
  
  


  // Dynamic Hit Area: Parameters Change Based On Pulse, Changes Cursor Style

  if (dist(mouseX, mouseY, width/2, height/2) < currentDiameter / 2) {
    cursor('pointer');
    
  } else {
    
    cursor('default');
    
  }
}

function titleScreenClick() {
  
  let pulse = sin(frameCount * 0.05) * 10;
  let currentDiameter = 350 + pulse;
  
  if (dist(mouseX, mouseY, width / 2, height / 2) < currentDiameter / 2) {
    level = 1;      
    cursor('default');     // Reset cursor
  }
}


// SETUP

level = 0

function setup() {
  
  createCanvas(windowWidth, windowHeight);
  
  noStroke();

  
  rectMode(CENTER);
  
  ellipseMode(CENTER);

  resetOrb();
  
}

// DRAW - MAIN CODE BODY

function draw() {
  
  
  background(black); 
  
  
  updateParticles();
  
 push(); 
    
switch (level) {
    
    case 0:  drawTitleScreen(); break;
    case 1:  drawLevel1(); break;
    case 2:  drawLevel2(); break;
    case 3:  drawLevel3(); break;
    case 4:  drawLevel4(); break;
    case 5:  drawLevel5(); break;
    case 6:  drawLevel6(); break;
    case 7:  drawLevel7(); break;
    case 8:  drawLevel8(); break;
    case 9:  drawLevel9(); break;
    case 10: drawLevel10(); break;
      
    default:
      fill(white);
      textAlign(CENTER);
      text("complete", width/2, height/2);
      break;
  }
  
  pop();
  
  drawUI();
  transition();
  
}

function resetOrb() {
    
    target = createVector(width/2, height/2);
}

function drawUI() {
    if (level === 0) return;
    
    for(let i=1; i<=maxLevels; i++) {
        fill(i === level ? 255 : 50);
        let spacing = 20;
        let totalWidth = maxLevels * spacing;
        let startX = (width/2) - (totalWidth/2);
        ellipse(startX + (i*spacing), height - 30, 6);
    }
}

function startTransition() {
    transitionState = 'OUT';
    transitionAlpha = 0;
}


function transition() {
    if (transitionState !== 'NONE') {
        fill(0, transitionAlpha);
        rect(width/2, height/2, width, height);
    }

    if (transitionState === 'OUT') {
        transitionAlpha += 10; 
        if (transitionAlpha >= 255) {
            transitionState = 'IN';
            level++; 
            if (level > maxLevels) level = 0;
            
            
            resetOrb(); 
        }
    } else if (transitionState === 'IN') {
        transitionAlpha -= 10; 
        if (transitionAlpha <= 0) {
            transitionState = 'NONE';
        }
    }
}



function keyPressed() {
  if (key === 'f' || key === 'F') {
      fullscreen(!fullscreen());
  }
}

function mousePressed() {
  
  if (transitionState !== 'NONE') return;

  // LEVEL 0 (TITLE)
  if (level === 0) {
    let pulse = sin(frameCount * 0.05) * 10;
    let currentDiameter = 350 + pulse;
    
    if (dist(mouseX, mouseY, width/2, height/2) < currentDiameter / 2) {
      spawnParticles(width/2, height/2, 50, white);
      titleScreenClick(); 
    }
  } 
  
  
  else if (level >= 1 && level <= 10) {
      
      
      if (dist(mouseX, mouseY, target.x, target.y) < 50) {
          spawnParticles(target.x, target.y, 40, goodgreen);
          startTransition();
      } else {
        
      }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // center orb after resize 
  if(target) {
      target.x = width/2;
      target.y = height/2;
  }
}
    
  




  
// LEVEL 1 INTERACTION
//   else if (level === 1) {
//      checkLevel1Click();  
//   }
  
//   LEVEL 2 INTERACTION
//   else if (level === 2) {
//      checkLevel2Click(); 
//   }
